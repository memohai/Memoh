// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: channel_identities.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChannelIdentity = `-- name: CreateChannelIdentity :one
INSERT INTO channel_identities (user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
`

type CreateChannelIdentityParams struct {
	UserID           pgtype.UUID `json:"user_id"`
	ChannelType      string      `json:"channel_type"`
	ChannelSubjectID string      `json:"channel_subject_id"`
	DisplayName      pgtype.Text `json:"display_name"`
	AvatarUrl        pgtype.Text `json:"avatar_url"`
	Metadata         []byte      `json:"metadata"`
}

func (q *Queries) CreateChannelIdentity(ctx context.Context, arg CreateChannelIdentityParams) (ChannelIdentity, error) {
	row := q.db.QueryRow(ctx, createChannelIdentity,
		arg.UserID,
		arg.ChannelType,
		arg.ChannelSubjectID,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Metadata,
	)
	var i ChannelIdentity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelType,
		&i.ChannelSubjectID,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChannelIdentityByChannelSubject = `-- name: GetChannelIdentityByChannelSubject :one
SELECT id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
FROM channel_identities
WHERE channel_type = $1 AND channel_subject_id = $2
`

type GetChannelIdentityByChannelSubjectParams struct {
	ChannelType      string `json:"channel_type"`
	ChannelSubjectID string `json:"channel_subject_id"`
}

func (q *Queries) GetChannelIdentityByChannelSubject(ctx context.Context, arg GetChannelIdentityByChannelSubjectParams) (ChannelIdentity, error) {
	row := q.db.QueryRow(ctx, getChannelIdentityByChannelSubject, arg.ChannelType, arg.ChannelSubjectID)
	var i ChannelIdentity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelType,
		&i.ChannelSubjectID,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChannelIdentityByID = `-- name: GetChannelIdentityByID :one
SELECT id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
FROM channel_identities
WHERE id = $1
`

func (q *Queries) GetChannelIdentityByID(ctx context.Context, id pgtype.UUID) (ChannelIdentity, error) {
	row := q.db.QueryRow(ctx, getChannelIdentityByID, id)
	var i ChannelIdentity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelType,
		&i.ChannelSubjectID,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChannelIdentityByIDForUpdate = `-- name: GetChannelIdentityByIDForUpdate :one
SELECT id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
FROM channel_identities
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetChannelIdentityByIDForUpdate(ctx context.Context, id pgtype.UUID) (ChannelIdentity, error) {
	row := q.db.QueryRow(ctx, getChannelIdentityByIDForUpdate, id)
	var i ChannelIdentity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelType,
		&i.ChannelSubjectID,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listChannelIdentitiesByUserID = `-- name: ListChannelIdentitiesByUserID :many
SELECT id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
FROM channel_identities
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListChannelIdentitiesByUserID(ctx context.Context, userID pgtype.UUID) ([]ChannelIdentity, error) {
	rows, err := q.db.Query(ctx, listChannelIdentitiesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChannelIdentity
	for rows.Next() {
		var i ChannelIdentity
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ChannelType,
			&i.ChannelSubjectID,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setChannelIdentityLinkedUser = `-- name: SetChannelIdentityLinkedUser :one
UPDATE channel_identities
SET user_id = $2, updated_at = now()
WHERE id = $1
RETURNING id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
`

type SetChannelIdentityLinkedUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) SetChannelIdentityLinkedUser(ctx context.Context, arg SetChannelIdentityLinkedUserParams) (ChannelIdentity, error) {
	row := q.db.QueryRow(ctx, setChannelIdentityLinkedUser, arg.ID, arg.UserID)
	var i ChannelIdentity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelType,
		&i.ChannelSubjectID,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertChannelIdentityByChannelSubject = `-- name: UpsertChannelIdentityByChannelSubject :one
INSERT INTO channel_identities (user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (channel_type, channel_subject_id)
DO UPDATE SET
  display_name = COALESCE(NULLIF(EXCLUDED.display_name, ''), channel_identities.display_name),
  avatar_url = COALESCE(NULLIF(EXCLUDED.avatar_url, ''), channel_identities.avatar_url),
  metadata = EXCLUDED.metadata,
  user_id = COALESCE(channel_identities.user_id, EXCLUDED.user_id),
  updated_at = now()
RETURNING id, user_id, channel_type, channel_subject_id, display_name, avatar_url, metadata, created_at, updated_at
`

type UpsertChannelIdentityByChannelSubjectParams struct {
	UserID           pgtype.UUID `json:"user_id"`
	ChannelType      string      `json:"channel_type"`
	ChannelSubjectID string      `json:"channel_subject_id"`
	DisplayName      pgtype.Text `json:"display_name"`
	AvatarUrl        pgtype.Text `json:"avatar_url"`
	Metadata         []byte      `json:"metadata"`
}

func (q *Queries) UpsertChannelIdentityByChannelSubject(ctx context.Context, arg UpsertChannelIdentityByChannelSubjectParams) (ChannelIdentity, error) {
	row := q.db.QueryRow(ctx, upsertChannelIdentityByChannelSubject,
		arg.UserID,
		arg.ChannelType,
		arg.ChannelSubjectID,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Metadata,
	)
	var i ChannelIdentity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChannelType,
		&i.ChannelSubjectID,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
