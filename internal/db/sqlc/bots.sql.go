// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bots.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBot = `-- name: CreateBot :one
INSERT INTO bots (owner_user_id, type, display_name, avatar_url, is_active, metadata, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, owner_user_id, type, display_name, avatar_url, is_active, status, max_context_load_time, max_context_tokens, language, allow_guest, chat_model_id, memory_model_id, embedding_model_id, search_provider_id, metadata, created_at, updated_at
`

type CreateBotParams struct {
	OwnerUserID pgtype.UUID `json:"owner_user_id"`
	Type        string      `json:"type"`
	DisplayName pgtype.Text `json:"display_name"`
	AvatarUrl   pgtype.Text `json:"avatar_url"`
	IsActive    bool        `json:"is_active"`
	Metadata    []byte      `json:"metadata"`
	Status      string      `json:"status"`
}

func (q *Queries) CreateBot(ctx context.Context, arg CreateBotParams) (Bot, error) {
	row := q.db.QueryRow(ctx, createBot,
		arg.OwnerUserID,
		arg.Type,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.IsActive,
		arg.Metadata,
		arg.Status,
	)
	var i Bot
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Type,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.IsActive,
		&i.Status,
		&i.MaxContextLoadTime,
		&i.MaxContextTokens,
		&i.Language,
		&i.AllowGuest,
		&i.ChatModelID,
		&i.MemoryModelID,
		&i.EmbeddingModelID,
		&i.SearchProviderID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBotByID = `-- name: DeleteBotByID :exec
DELETE FROM bots WHERE id = $1
`

func (q *Queries) DeleteBotByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBotByID, id)
	return err
}

const deleteBotMember = `-- name: DeleteBotMember :exec
DELETE FROM bot_members WHERE bot_id = $1 AND user_id = $2
`

type DeleteBotMemberParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteBotMember(ctx context.Context, arg DeleteBotMemberParams) error {
	_, err := q.db.Exec(ctx, deleteBotMember, arg.BotID, arg.UserID)
	return err
}

const getBotByID = `-- name: GetBotByID :one
SELECT id, owner_user_id, type, display_name, avatar_url, is_active, status, max_context_load_time, max_context_tokens, language, allow_guest, chat_model_id, memory_model_id, embedding_model_id, search_provider_id, metadata, created_at, updated_at
FROM bots
WHERE id = $1
`

func (q *Queries) GetBotByID(ctx context.Context, id pgtype.UUID) (Bot, error) {
	row := q.db.QueryRow(ctx, getBotByID, id)
	var i Bot
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Type,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.IsActive,
		&i.Status,
		&i.MaxContextLoadTime,
		&i.MaxContextTokens,
		&i.Language,
		&i.AllowGuest,
		&i.ChatModelID,
		&i.MemoryModelID,
		&i.EmbeddingModelID,
		&i.SearchProviderID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBotMember = `-- name: GetBotMember :one
SELECT bot_id, user_id, role, created_at
FROM bot_members
WHERE bot_id = $1 AND user_id = $2
LIMIT 1
`

type GetBotMemberParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetBotMember(ctx context.Context, arg GetBotMemberParams) (BotMember, error) {
	row := q.db.QueryRow(ctx, getBotMember, arg.BotID, arg.UserID)
	var i BotMember
	err := row.Scan(
		&i.BotID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const listBotMembers = `-- name: ListBotMembers :many
SELECT bot_id, user_id, role, created_at
FROM bot_members
WHERE bot_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListBotMembers(ctx context.Context, botID pgtype.UUID) ([]BotMember, error) {
	rows, err := q.db.Query(ctx, listBotMembers, botID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotMember
	for rows.Next() {
		var i BotMember
		if err := rows.Scan(
			&i.BotID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBotsByMember = `-- name: ListBotsByMember :many
SELECT b.id, b.owner_user_id, b.type, b.display_name, b.avatar_url, b.is_active, b.status, b.max_context_load_time, b.max_context_tokens, b.language, b.allow_guest, b.chat_model_id, b.memory_model_id, b.embedding_model_id, b.search_provider_id, b.metadata, b.created_at, b.updated_at
FROM bots b
JOIN bot_members m ON m.bot_id = b.id
WHERE m.user_id = $1
ORDER BY b.created_at DESC
`

func (q *Queries) ListBotsByMember(ctx context.Context, userID pgtype.UUID) ([]Bot, error) {
	rows, err := q.db.Query(ctx, listBotsByMember, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bot
	for rows.Next() {
		var i Bot
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Type,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.IsActive,
			&i.Status,
			&i.MaxContextLoadTime,
			&i.MaxContextTokens,
			&i.Language,
			&i.AllowGuest,
			&i.ChatModelID,
			&i.MemoryModelID,
			&i.EmbeddingModelID,
			&i.SearchProviderID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBotsByOwner = `-- name: ListBotsByOwner :many
SELECT id, owner_user_id, type, display_name, avatar_url, is_active, status, max_context_load_time, max_context_tokens, language, allow_guest, chat_model_id, memory_model_id, embedding_model_id, search_provider_id, metadata, created_at, updated_at
FROM bots
WHERE owner_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListBotsByOwner(ctx context.Context, ownerUserID pgtype.UUID) ([]Bot, error) {
	rows, err := q.db.Query(ctx, listBotsByOwner, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bot
	for rows.Next() {
		var i Bot
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Type,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.IsActive,
			&i.Status,
			&i.MaxContextLoadTime,
			&i.MaxContextTokens,
			&i.Language,
			&i.AllowGuest,
			&i.ChatModelID,
			&i.MemoryModelID,
			&i.EmbeddingModelID,
			&i.SearchProviderID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBotOwner = `-- name: UpdateBotOwner :one
UPDATE bots
SET owner_user_id = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, owner_user_id, type, display_name, avatar_url, is_active, status, max_context_load_time, max_context_tokens, language, allow_guest, chat_model_id, memory_model_id, embedding_model_id, search_provider_id, metadata, created_at, updated_at
`

type UpdateBotOwnerParams struct {
	ID          pgtype.UUID `json:"id"`
	OwnerUserID pgtype.UUID `json:"owner_user_id"`
}

func (q *Queries) UpdateBotOwner(ctx context.Context, arg UpdateBotOwnerParams) (Bot, error) {
	row := q.db.QueryRow(ctx, updateBotOwner, arg.ID, arg.OwnerUserID)
	var i Bot
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Type,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.IsActive,
		&i.Status,
		&i.MaxContextLoadTime,
		&i.MaxContextTokens,
		&i.Language,
		&i.AllowGuest,
		&i.ChatModelID,
		&i.MemoryModelID,
		&i.EmbeddingModelID,
		&i.SearchProviderID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBotProfile = `-- name: UpdateBotProfile :one
UPDATE bots
SET display_name = $2,
    avatar_url = $3,
    is_active = $4,
    metadata = $5,
    updated_at = now()
WHERE id = $1
RETURNING id, owner_user_id, type, display_name, avatar_url, is_active, status, max_context_load_time, max_context_tokens, language, allow_guest, chat_model_id, memory_model_id, embedding_model_id, search_provider_id, metadata, created_at, updated_at
`

type UpdateBotProfileParams struct {
	ID          pgtype.UUID `json:"id"`
	DisplayName pgtype.Text `json:"display_name"`
	AvatarUrl   pgtype.Text `json:"avatar_url"`
	IsActive    bool        `json:"is_active"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) UpdateBotProfile(ctx context.Context, arg UpdateBotProfileParams) (Bot, error) {
	row := q.db.QueryRow(ctx, updateBotProfile,
		arg.ID,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.IsActive,
		arg.Metadata,
	)
	var i Bot
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Type,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.IsActive,
		&i.Status,
		&i.MaxContextLoadTime,
		&i.MaxContextTokens,
		&i.Language,
		&i.AllowGuest,
		&i.ChatModelID,
		&i.MemoryModelID,
		&i.EmbeddingModelID,
		&i.SearchProviderID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBotStatus = `-- name: UpdateBotStatus :exec
UPDATE bots
SET status = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateBotStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateBotStatus(ctx context.Context, arg UpdateBotStatusParams) error {
	_, err := q.db.Exec(ctx, updateBotStatus, arg.ID, arg.Status)
	return err
}

const upsertBotMember = `-- name: UpsertBotMember :one
INSERT INTO bot_members (bot_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (bot_id, user_id) DO UPDATE SET
  role = EXCLUDED.role
RETURNING bot_id, user_id, role, created_at
`

type UpsertBotMemberParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	UserID pgtype.UUID `json:"user_id"`
	Role   string      `json:"role"`
}

func (q *Queries) UpsertBotMember(ctx context.Context, arg UpsertBotMemberParams) (BotMember, error) {
	row := q.db.QueryRow(ctx, upsertBotMember, arg.BotID, arg.UserID, arg.Role)
	var i BotMember
	err := row.Scan(
		&i.BotID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}
