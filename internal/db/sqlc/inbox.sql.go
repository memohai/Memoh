// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inbox.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInboxItems = `-- name: CountInboxItems :one
SELECT count(*) FROM bot_inbox
WHERE bot_id = $1
`

func (q *Queries) CountInboxItems(ctx context.Context, botID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInboxItems, botID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadInboxItems = `-- name: CountUnreadInboxItems :one
SELECT count(*) FROM bot_inbox
WHERE bot_id = $1
  AND is_read = FALSE
`

func (q *Queries) CountUnreadInboxItems(ctx context.Context, botID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadInboxItems, botID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInboxItem = `-- name: CreateInboxItem :one
INSERT INTO bot_inbox (bot_id, source, content)
VALUES ($1, $2, $3)
RETURNING id, bot_id, source, content, is_read, created_at, read_at
`

type CreateInboxItemParams struct {
	BotID   pgtype.UUID `json:"bot_id"`
	Source  string      `json:"source"`
	Content []byte      `json:"content"`
}

func (q *Queries) CreateInboxItem(ctx context.Context, arg CreateInboxItemParams) (BotInbox, error) {
	row := q.db.QueryRow(ctx, createInboxItem, arg.BotID, arg.Source, arg.Content)
	var i BotInbox
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.Source,
		&i.Content,
		&i.IsRead,
		&i.CreatedAt,
		&i.ReadAt,
	)
	return i, err
}

const deleteInboxItem = `-- name: DeleteInboxItem :exec
DELETE FROM bot_inbox
WHERE id = $1
  AND bot_id = $2
`

type DeleteInboxItemParams struct {
	ID    pgtype.UUID `json:"id"`
	BotID pgtype.UUID `json:"bot_id"`
}

func (q *Queries) DeleteInboxItem(ctx context.Context, arg DeleteInboxItemParams) error {
	_, err := q.db.Exec(ctx, deleteInboxItem, arg.ID, arg.BotID)
	return err
}

const deleteInboxItemsByBot = `-- name: DeleteInboxItemsByBot :exec
DELETE FROM bot_inbox
WHERE bot_id = $1
`

func (q *Queries) DeleteInboxItemsByBot(ctx context.Context, botID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteInboxItemsByBot, botID)
	return err
}

const getInboxItemByID = `-- name: GetInboxItemByID :one
SELECT id, bot_id, source, content, is_read, created_at, read_at FROM bot_inbox
WHERE id = $1
  AND bot_id = $2
`

type GetInboxItemByIDParams struct {
	ID    pgtype.UUID `json:"id"`
	BotID pgtype.UUID `json:"bot_id"`
}

func (q *Queries) GetInboxItemByID(ctx context.Context, arg GetInboxItemByIDParams) (BotInbox, error) {
	row := q.db.QueryRow(ctx, getInboxItemByID, arg.ID, arg.BotID)
	var i BotInbox
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.Source,
		&i.Content,
		&i.IsRead,
		&i.CreatedAt,
		&i.ReadAt,
	)
	return i, err
}

const listInboxItems = `-- name: ListInboxItems :many
SELECT id, bot_id, source, content, is_read, created_at, read_at FROM bot_inbox
WHERE bot_id = $1
  AND ($2::boolean IS NULL OR is_read = $2::boolean)
  AND ($3::text IS NULL OR source = $3::text)
ORDER BY created_at DESC
LIMIT $5
OFFSET $4
`

type ListInboxItemsParams struct {
	BotID      pgtype.UUID `json:"bot_id"`
	IsRead     pgtype.Bool `json:"is_read"`
	Source     pgtype.Text `json:"source"`
	ItemOffset int32       `json:"item_offset"`
	MaxCount   int32       `json:"max_count"`
}

func (q *Queries) ListInboxItems(ctx context.Context, arg ListInboxItemsParams) ([]BotInbox, error) {
	rows, err := q.db.Query(ctx, listInboxItems,
		arg.BotID,
		arg.IsRead,
		arg.Source,
		arg.ItemOffset,
		arg.MaxCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotInbox
	for rows.Next() {
		var i BotInbox
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.Source,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreadInboxItems = `-- name: ListUnreadInboxItems :many
SELECT id, bot_id, source, content, is_read, created_at, read_at FROM bot_inbox
WHERE bot_id = $1
  AND is_read = FALSE
ORDER BY created_at ASC
LIMIT $2
`

type ListUnreadInboxItemsParams struct {
	BotID    pgtype.UUID `json:"bot_id"`
	MaxCount int32       `json:"max_count"`
}

func (q *Queries) ListUnreadInboxItems(ctx context.Context, arg ListUnreadInboxItemsParams) ([]BotInbox, error) {
	rows, err := q.db.Query(ctx, listUnreadInboxItems, arg.BotID, arg.MaxCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotInbox
	for rows.Next() {
		var i BotInbox
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.Source,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInboxItemsRead = `-- name: MarkInboxItemsRead :exec
UPDATE bot_inbox
SET is_read = TRUE,
    read_at = now()
WHERE bot_id = $1
  AND id = ANY($2::uuid[])
  AND is_read = FALSE
`

type MarkInboxItemsReadParams struct {
	BotID pgtype.UUID   `json:"bot_id"`
	Ids   []pgtype.UUID `json:"ids"`
}

func (q *Queries) MarkInboxItemsRead(ctx context.Context, arg MarkInboxItemsReadParams) error {
	_, err := q.db.Exec(ctx, markInboxItemsRead, arg.BotID, arg.Ids)
	return err
}

const searchInboxItems = `-- name: SearchInboxItems :many
SELECT id, bot_id, source, content, is_read, created_at, read_at FROM bot_inbox
WHERE bot_id = $1
  AND content::text ILIKE '%' || $2 || '%'
  AND ($3::timestamptz IS NULL OR created_at >= $3::timestamptz)
  AND ($4::timestamptz IS NULL OR created_at <= $4::timestamptz)
  AND ($5::boolean IS NULL OR $5::boolean = TRUE OR is_read = FALSE)
ORDER BY created_at DESC
LIMIT $6
`

type SearchInboxItemsParams struct {
	BotID       pgtype.UUID        `json:"bot_id"`
	Query       pgtype.Text        `json:"query"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	EndTime     pgtype.Timestamptz `json:"end_time"`
	IncludeRead pgtype.Bool        `json:"include_read"`
	MaxCount    int32              `json:"max_count"`
}

func (q *Queries) SearchInboxItems(ctx context.Context, arg SearchInboxItemsParams) ([]BotInbox, error) {
	rows, err := q.db.Query(ctx, searchInboxItems,
		arg.BotID,
		arg.Query,
		arg.StartTime,
		arg.EndTime,
		arg.IncludeRead,
		arg.MaxCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotInbox
	for rows.Next() {
		var i BotInbox
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.Source,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
